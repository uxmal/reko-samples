// base_offset_return-sh4-linux-gnu-gcc-9_text.c
// Generated by decompiling base_offset_return-sh4-linux-gnu-gcc-9
// using Reko decompiler version 0.9.3.0.

#include "base_offset_return-sh4-linux-gnu-gcc-9.h"

// 00000398: void deregister_tm_clones(Register word32 pr)
void deregister_tm_clones(word32 pr)
{
	int32 r12_n = g_dw03C0 + 0x03C0;
	if (g_dw03C8 + r12_n == g_dw03C4 + r12_n)
		return;
	<anonymous> ** r1_n = g_ptr03CC + r12_n;
	if (r1_n == null)
		return;
	(*r1_n)();
}

word32 g_dw03C0 = 68676;
word32 g_dw03C4 = 0x00;
word32 g_dw03C8 = 0x00;
ptr32 g_ptr03CC = 0x18;
// 000003D0: void register_tm_clones(Register word32 pr)
void register_tm_clones(word32 pr)
{
	int32 r12_n = g_dw0408 + 0x0408;
	if ((g_dw0410 + r12_n - (g_dw040C + r12_n) >> 2) + T >> 1 == 0x00)
		return;
	<anonymous> ** r1_n = g_ptr0414 + r12_n;
	if (r1_n == null)
		return;
	(*r1_n)();
}

word32 g_dw0408 = 68604;
word32 g_dw040C = 0x00;
word32 g_dw0410 = 0x00;
ptr32 g_ptr0414 = 0x20;
// 00000418: void __do_global_dtors_aux(Register word32 r8, Register word32 r9, Register word32 r11, Register word32 pr)
void __do_global_dtors_aux(word32 r8, word32 r9, word32 r11, word32 pr)
{
	int32 r10_n = g_dw0490;
	ptr32 r12_n = g_dw048C + 1164;
	if (!(r12_n + r10_n == 0x00))
		return;
	if (g_dw0494 + r12_n == 0x00)
	{
		struct Eq_n * r11_n = g_dw04A8 + r12_n;
		int32 r1_n = g_dw04A0;
		Eq_n r0_n = r11_n->dw0000;
		Eq_n r8_n = (g_dw04A4 - r1_n >> 2) + ~0x00;
		int32 r9_n = r1_n + r12_n;
		if (r0_n < r8_n)
		{
			uint32 r0_n = (word32) r0_n.u1 + 1;
			while (true)
			{
				r11_n->dw0000 = r0_n;
				<anonymous> **** r0_n[] = r0_n << 2;
				<anonymous> ** r1_n = r0_n[r9_n / 4];
				word32 r4_n;
				(*r1_n)();
				Eq_n r0_n = r11_n->dw0000;
				if (r0_n >= r8_n)
					break;
				r0_n = (word32) r0_n.u1 + 1;
			}
		}
		int32 r0_n = g_dw04AC;
		int32 r10_n;
		ptr32 r12_n;
		word32 r4_n;
		(1144 + r0_n)();
		r12_n + r10_n = 0x01;
	}
	else
	{
		word32 r0_n = g_dw049C;
		int32 r1_n = g_dw0498;
		(0x0444 + r1_n)();
	}
}

word32 g_dw048C = 0x00010B78;
int32 g_dw0490 = 36;
int32 g_dw0494 = 20;
int32 g_dw0498 = -228;
word32 g_dw049C = ~0x03;
int32 g_dw04A0 = -228;
int32 g_dw04A4 = -224;
word32 g_dw04A8 = 0x28;
int32 g_dw04AC = -224;
// 000004B0: void frame_dummy()
void frame_dummy()
{
	int32 r1_n = g_dw04B8;
	(0x04B6 + r1_n)();
}

int32 g_dw04B8 = -0x00E6;
// 000004BC: void getIndex()
void getIndex()
{
}

// 000004C4: void foo(Register word32 r4, Register word32 r8, Register word32 pr)
void foo(word32 r4, word32 r8, word32 pr)
{
	if (r4 == 0x00)
		return;
	ui32 r0_n;
	word32 r8_n[];
	fn464C457E();
	r8_n[r0_n] = 0x00;
}

// 000004EC: void __do_global_ctors_aux(Register word32 pr)
void __do_global_ctors_aux(word32 pr)
{
	word32 r12_n = g_dw051C + 0x051C;
	struct Eq_n * r8_n = g_dw0520 + r12_n;
	<anonymous> ** r0_n = r8_n->ptrFFFFFFFC;
	if (r0_n != (<anonymous> **) ~0x00)
	{
		word32 * r8_n = &r8_n->ptrFFFFFFFC;
		do
		{
			(*r0_n)();
			r0_n = *r8_n;
		} while (!(r0_n == (<anonymous> **) ~0x00));
	}
}

word32 g_dw051C = 68328;
word32 g_dw0520 = ~0xE7;
