// hexdump-Os_text.c
// Generated by decompiling hexdump-Os.so
// using Reko decompiler version 0.9.3.0.

#include "hexdump-Os.h"

// 00000410: void main(Register word32 r4, Register word32 r5, Register word32 r8, Register word32 r12, Register word32 pr)
void main(word32 r4, word32 r5, word32 r8, word32 r12, word32 pr)
{
	int32 r1_n = g_dw044C;
	ui32 * r15_n;
	ui32 r8_n;
	word32 r0_n;
	word32 r12_n;
	word32 pr_n;
	(0x0426 + r1_n)();
	*r15_n = r8_n * 0x02;
	word32 r0_n = g_dw0454;
	int32 r1_n = g_dw0450;
	(0x043A + r1_n)();
}

int32 g_dw044C = -78;
int32 g_dw0450 = -70;
word32 g_dw0454 = 0x28;
// 00000458: void deregister_tm_clones(Register word32 pr)
void deregister_tm_clones(word32 pr)
{
	int32 r12_n = g_dw0480 + 0x0480;
	if (g_dw0488 + r12_n == g_dw0484 + r12_n)
		return;
	<anonymous> ** r1_n = g_ptr048C + r12_n;
	if (r1_n == null)
		return;
	(*r1_n)();
}

word32 g_dw0480 = 68484;
word32 g_dw0484 = 0x00;
word32 g_dw0488 = 0x00;
ptr32 g_ptr048C = 0x20;
// 00000490: void register_tm_clones(Register word32 pr)
void register_tm_clones(word32 pr)
{
	int32 r12_n = g_dw04C8 + 1224;
	if ((g_dw04D0 + r12_n - (g_dw04CC + r12_n) >> 2) + T >> 1 == 0x00)
		return;
	<anonymous> ** r1_n = g_ptr04D4 + r12_n;
	if (r1_n == null)
		return;
	(*r1_n)();
}

word32 g_dw04C8 = 0x00010B3C;
word32 g_dw04CC = 0x00;
word32 g_dw04D0 = 0x00;
ptr32 g_ptr04D4 = 44;
// 000004D8: void __do_global_dtors_aux(Register word32 r8, Register word32 r9, Register word32 r11, Register word32 pr)
void __do_global_dtors_aux(word32 r8, word32 r9, word32 r11, word32 pr)
{
	int32 r10_n = g_dw0550;
	ptr32 r12_n = g_dw054C + 0x054C;
	if (!(r12_n + r10_n == 0x00))
		return;
	if (g_dw0554 + r12_n == 0x00)
	{
		struct Eq_n * r11_n = g_dw0568 + r12_n;
		int32 r1_n = g_dw0560;
		Eq_n r0_n = r11_n->dw0000;
		Eq_n r8_n = (g_dw0564 - r1_n >> 2) + ~0x00;
		int32 r9_n = r1_n + r12_n;
		if (r0_n < r8_n)
		{
			uint32 r0_n = (word32) r0_n.u1 + 1;
			while (true)
			{
				r11_n->dw0000 = r0_n;
				<anonymous> **** r0_n[] = r0_n << 2;
				<anonymous> ** r1_n = r0_n[r9_n / 4];
				word32 r4_n;
				(*r1_n)();
				Eq_n r0_n = r11_n->dw0000;
				if (r0_n >= r8_n)
					break;
				r0_n = (word32) r0_n.u1 + 1;
			}
		}
		int32 r0_n = g_dw056C;
		int32 r10_n;
		ptr32 r12_n;
		word32 r4_n;
		(1336 + r0_n)();
		r12_n + r10_n = 0x01;
	}
	else
	{
		word32 r0_n = g_dw055C;
		int32 r1_n = g_dw0558;
		(0x0504 + r1_n)();
	}
}

word32 g_dw054C = 68280;
int32 g_dw0550 = 48;
int32 g_dw0554 = 28;
int32 g_dw0558 = -356;
word32 g_dw055C = ~0x03;
int32 g_dw0560 = -212;
int32 g_dw0564 = -0x00D0;
word32 g_dw0568 = 0x34;
int32 g_dw056C = -224;
// 00000570: void frame_dummy()
void frame_dummy()
{
	int32 r1_n = g_dw0578;
	(0x0576 + r1_n)();
}

int32 g_dw0578 = -0x00E6;
// 0000057C: void hexdump()
void hexdump()
{
}

// 00000580: void __do_global_ctors_aux(Register word32 pr)
void __do_global_ctors_aux(word32 pr)
{
	word32 r12_n = g_dw05B0 + 0x05B0;
	struct Eq_n * r8_n = g_dw05B4 + r12_n;
	<anonymous> ** r0_n = r8_n->ptrFFFFFFFC;
	if (r0_n != (<anonymous> **) ~0x00)
	{
		word32 * r8_n = &r8_n->ptrFFFFFFFC;
		do
		{
			(*r0_n)();
			r0_n = *r8_n;
		} while (!(r0_n == (<anonymous> **) ~0x00));
	}
}

word32 g_dw05B0 = 68180;
word32 g_dw05B4 = ~0xD7;
